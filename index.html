<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é‡‘å¥å¡ç‰‡å·¥å‚-Canvasç»ˆæå¼•æ“</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* å¼•å…¥éœ€è¦çš„å­—ä½“ */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700;900&family=Noto+Sans+SC:wght@300;400;700;900&family=Zcool+KuaiLe&display=swap');
        
        body { font-family: 'Noto Sans SC', sans-serif; background-color: #1a1a1a; color: #e5e5e5; }
        
        /* éšè—æ»šåŠ¨æ¡ä½†ä¿ç•™åŠŸèƒ½ */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* è‡ªå®šä¹‰ç»†æ»šåŠ¨æ¡ç”¨äºè¾“å…¥æ¡† */
        .input-scrollbar::-webkit-scrollbar { width: 4px; }
        .input-scrollbar::-webkit-scrollbar-track { background: #222; }
        .input-scrollbar::-webkit-scrollbar-thumb { background: #444; border-radius: 2px; }
        .input-scrollbar::-webkit-scrollbar-thumb:hover { background: #555; }
        
        input:focus, textarea:focus { border-color: #3b82f6 !important; background-color: #2a2a2a !important; }

        /* é€‰ä¸­é«˜äº® */
        .card-highlight {
            outline: 4px solid #3b82f6;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
        }
    </style>

    <!-- æ ¸å¿ƒåº“ -->
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
</head>
<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useMemo, useCallback } = React;

        // --- æ ¸å¿ƒé…ç½® ---
        // ç”»å¸ƒå†…éƒ¨çœŸå®åˆ†è¾¨ç‡ (é«˜æ¸…)
        const CANVAS_WIDTH = 1200;
        const CANVAS_HEIGHT = 1600;

        const defaultCards = [
            {
                title: "çº¯Canvaså¼•æ“",
                engTitle: "PURE CANVAS ENGINE",
                icon: "ğŸš€",
                quote: "æ‚¨ç°åœ¨çš„é¢„è§ˆå›¾å°±æ˜¯æœ€ç»ˆç»“æœã€‚æ‰€æœ‰æ–‡å­—ã€çº¿æ¡éƒ½æ˜¯é€šè¿‡åæ ‡ç²¾å‡†ç»˜åˆ¶çš„ï¼Œå½»åº•å‘Šåˆ«å®‰å“Webviewé”™ä½ã€‚",
                desc: "è¿™ç§æ–¹å¼å°±åƒåœ¨çº¸ä¸Šç”»ç”»ï¼Œä¸ç®¡åœ¨ä»€ä¹ˆè®¾å¤‡ä¸Šï¼Œåƒç´ ä½ç½®æ°¸è¿œå›ºå®šã€‚",
                tag: "#ç»ˆææ–¹æ¡ˆ #åƒç´ çº§",
                author: "@CanvasMaster",
                scales: { title: 1.0, eng: 1.0, quote: 1.0, desc: 1.0 }
            },
            { title: "æ³¢æ™®è‰ºæœ¯æµ‹è¯•", engTitle: "POP ART TEST", icon: "ğŸ’¥", quote: "çœ‹ä¸Šé¢çš„æ ‡é¢˜ï¼Œé‚£æ˜¯é€šè¿‡æ•°å­¦æ—‹è½¬ç»˜åˆ¶çš„ï¼Œå¯¼å‡ºç»å¯¹ä¸ä¼šæ­ªã€‚", desc: "Canvas ç»˜åˆ¶æ—‹è½¬æ–‡å­—æ¯” CSS ç¨³å®šä¸€ä¸‡å€ã€‚", tag: "#æµ‹è¯•", author: "@Dev", scales: { title: 1.0, eng: 1.0, quote: 1.0, desc: 1.0 } },
            { title: "å¤šå¼ é¢„è§ˆ", engTitle: "BATCH PREVIEW", icon: "ğŸ‘€", quote: "ç‚¹å‡»ä¸åŒæ•°é‡åˆ‡æ¢è§†å›¾ï¼Œç‚¹å‡»å¡ç‰‡å³å¯ç¼–è¾‘ã€‚æ‰€è§å³æ‰€å¾—ã€‚", desc: "æ€§èƒ½æå¿«ï¼Œç”Ÿæˆ 50 å¼ å›¾ä¹Ÿä¸ä¼šå¡é¡¿ã€‚", tag: "#é«˜æ•ˆ", author: "@Dev", scales: { title: 1.0, eng: 1.0, quote: 1.0, desc: 1.0 } },
        ];

        // --- ç»˜å›¾å·¥å…·å‡½æ•° ---
        
        // è‡ªåŠ¨æ¢è¡Œç»˜åˆ¶æ–‡æœ¬
        const drawWrappedText = (ctx, text, x, y, maxWidth, lineHeight, align = 'left') => {
            const words = text.split('');
            let line = '';
            const lines = [];

            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n];
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    lines.push(line);
                    line = words[n];
                } else {
                    line = testLine;
                }
            }
            lines.push(line);

            lines.forEach((l, i) => {
                let drawX = x;
                if (align === 'center') {
                    drawX = x + (maxWidth - ctx.measureText(l).width) / 2;
                } else if (align === 'right') {
                    drawX = x + maxWidth - ctx.measureText(l).width;
                }
                ctx.fillText(l, drawX, y + (i * lineHeight));
            });
            
            return lines.length * lineHeight; // è¿”å›æ€»é«˜åº¦
        };

        // --- é£æ ¼å®šä¹‰ (Canvas ç»˜å›¾é€»è¾‘) ---
        const styles = [
            {
                id: 'museum', name: 'æ–‡ç‰©æ¡£æ¡ˆ',
                draw: (ctx, card, w, h) => {
                    // èƒŒæ™¯
                    ctx.fillStyle = '#fdfbf7';
                    ctx.fillRect(0, 0, w, h);
                    
                    // åŒè¾¹æ¡†
                    ctx.strokeStyle = '#292524'; // stone-800
                    ctx.lineWidth = 4;
                    ctx.strokeRect(20, 20, w - 40, h - 40);
                    ctx.lineWidth = 1;
                    ctx.strokeRect(28, 28, w - 56, h - 56);

                    // æ ‡é¢˜ (å¸¦ä¸‹åˆ’çº¿)
                    ctx.fillStyle = '#1c1917';
                    ctx.font = `900 ${100 * card.scales.title}px "Noto Serif SC"`;
                    ctx.textBaseline = 'top';
                    ctx.fillText(card.title, 80, 100);
                    const titleWidth = ctx.measureText(card.title).width;
                    ctx.fillRect(80, 100 + 100 * card.scales.title + 10, titleWidth, 5);

                    // è‹±æ–‡
                    ctx.fillStyle = '#78716c';
                    ctx.font = `bold ${30 * card.scales.eng}px sans-serif`;
                    ctx.fillText(card.engTitle, 80, 100 + 100 * card.scales.title + 30);

                    // å›¾æ ‡
                    ctx.font = '100px sans-serif';
                    ctx.fillText(card.icon, w - 180, 100);

                    // é‡‘å¥ (å±…ä¸­)
                    ctx.fillStyle = '#292524';
                    ctx.font = `bold ${60 * card.scales.quote}px "Noto Serif SC"`;
                    const quoteY = h / 2 - 100;
                    drawWrappedText(ctx, card.quote, 100, quoteY, w - 200, 90 * card.scales.quote, 'left');

                    // åˆ†å‰²çº¿
                    ctx.fillStyle = '#d6d3d1';
                    ctx.fillRect(80, h - 350, w - 160, 2);

                    // æè¿°
                    ctx.fillStyle = '#57534e';
                    ctx.font = `italic ${40 * card.scales.desc}px "Noto Serif SC"`;
                    drawWrappedText(ctx, card.desc, 110, h - 300, w - 220, 60 * card.scales.desc, 'left');
                    ctx.fillStyle = '#a8a29e'; // å·¦ä¾§ç«–çº¿
                    ctx.fillRect(80, h - 300, 5, 120);

                    // åº•éƒ¨æ ‡ç­¾
                    ctx.fillStyle = '#292524';
                    ctx.fillRect(80, h - 120, ctx.measureText(card.tag).width + 40, 50);
                    ctx.fillStyle = '#fdfbf7';
                    ctx.font = '30px "Noto Serif SC"';
                    ctx.fillText(card.tag, 100, h - 110);

                    // ä½œè€…
                    ctx.fillStyle = '#78716c';
                    ctx.font = '30px monospace';
                    const authW = ctx.measureText(card.author).width;
                    ctx.fillText(card.author, w - 80 - authW, h - 110);
                }
            },
            {
                id: 'rednote', name: 'ç½‘çº¢å¤šå·´èƒº',
                draw: (ctx, card, w, h) => {
                    // æ¸å˜èƒŒæ™¯
                    const grd = ctx.createLinearGradient(0, 0, w, h);
                    grd.addColorStop(0, '#ffe4e6'); // rose-100
                    grd.addColorStop(1, '#ccfbf1'); // teal-100
                    ctx.fillStyle = grd;
                    ctx.fillRect(0, 0, w, h);
                    
                    // ç™½è¾¹æ¡†
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 30;
                    ctx.strokeRect(0, 0, w, h);

                    // æ ‡é¢˜ (å¿«ä¹ä½“)
                    ctx.fillStyle = '#e11d48'; // rose-600
                    ctx.font = `${140 * card.scales.title}px "Zcool KuaiLe"`;
                    ctx.textBaseline = 'top';
                    ctx.fillText(card.title, 80, 100);

                    // è‹±æ–‡
                    ctx.fillStyle = '#0d9488'; // teal-600
                    ctx.font = `bold ${35 * card.scales.eng}px sans-serif`;
                    ctx.fillText(card.engTitle, 80, 100 + 140 * card.scales.title + 20);

                    // å›¾æ ‡
                    ctx.font = '120px sans-serif';
                    ctx.fillText(card.icon, w - 200, 100);

                    // é‡‘å¥ (æ·±é’è‰²)
                    ctx.fillStyle = '#115e59';
                    ctx.font = `bold ${64 * card.scales.quote}px sans-serif`;
                    // å±…ä¸­è®¡ç®—
                    drawWrappedText(ctx, card.quote, 100, h/2 - 100, w - 200, 96 * card.scales.quote, 'left');

                    // è£…é¥°çº¿
                    ctx.fillStyle = '#0f766e';
                    ctx.fillRect(80, h - 320, 100, 8);

                    // æè¿°
                    ctx.fillStyle = '#4b5563';
                    ctx.font = `500 ${40 * card.scales.desc}px sans-serif`;
                    drawWrappedText(ctx, card.desc, 80, h - 280, w - 160, 60 * card.scales.desc, 'left');

                    // åº•éƒ¨èƒ¶å›Šæ ‡ç­¾
                    const tagW = ctx.measureText(card.tag).width + 60;
                    ctx.fillStyle = '#f43f5e';
                    ctx.beginPath();
                    ctx.roundRect(80, h - 120, tagW, 60, 30);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 32px sans-serif';
                    ctx.fillText(card.tag, 110, h - 108);

                    // ä½œè€…
                    ctx.fillStyle = '#4b5563';
                    const authW = ctx.measureText(card.author).width;
                    ctx.fillText(card.author, w - 80 - authW, h - 108);
                }
            },
            {
                id: 'pop', name: 'æ³¢æ™®è‰ºæœ¯',
                draw: (ctx, card, w, h) => {
                    // é»„åº•
                    ctx.fillStyle = '#facc15';
                    ctx.fillRect(0, 0, w, h);
                    // é»‘è¾¹
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 20;
                    ctx.strokeRect(10, 10, w-20, h-20);

                    // æ ‡é¢˜ (æ—‹è½¬)
                    ctx.save();
                    ctx.translate(100, 200);
                    ctx.rotate(-5 * Math.PI / 180);
                    ctx.fillStyle = '#000000';
                    ctx.font = `italic 900 ${120 * card.scales.title}px sans-serif`;
                    ctx.fillText(card.title, 0, 0);
                    ctx.restore();

                    // è‹±æ–‡ (æ—‹è½¬ + ç™½åº•è“å­—)
                    ctx.save();
                    ctx.translate(120, 200 + 120 * card.scales.title);
                    ctx.rotate(2 * Math.PI / 180);
                    const engFont = `bold ${40 * card.scales.eng}px sans-serif`;
                    ctx.font = engFont;
                    const engW = ctx.measureText(card.engTitle).width;
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-10, -40, engW + 20, 50);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(-10, -40, engW + 20, 50);
                    
                    ctx.fillStyle = '#2563eb';
                    ctx.fillText(card.engTitle, 0, -5);
                    ctx.restore();

                    // å›¾æ ‡
                    ctx.font = '120px sans-serif';
                    ctx.fillText(card.icon, w - 220, 150);

                    // é‡‘å¥ (ç™½åº•é»‘å­—é˜´å½±æ¡†)
                    const quoteBoxY = h/2 - 150;
                    const quoteBoxH = 400; // ä¼°ç®—é«˜åº¦
                    
                    // é˜´å½±
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(110, quoteBoxY + 10, w - 220, quoteBoxH);
                    // ç™½æ¡†
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(100, quoteBoxY, w - 220, quoteBoxH);
                    
                    ctx.fillStyle = '#000000';
                    ctx.font = `900 ${60 * card.scales.quote}px sans-serif`;
                    drawWrappedText(ctx, card.quote, 140, quoteBoxY + 80, w - 300, 80 * card.scales.quote, 'left');

                    // åº•éƒ¨
                    ctx.fillStyle = '#000000';
                    ctx.font = `bold ${40 * card.scales.desc}px sans-serif`;
                    drawWrappedText(ctx, card.desc, 100, h - 300, w - 200, 60 * card.scales.desc, 'left');

                    // æ ‡ç­¾ (è“åº•ç™½å­—)
                    const tagW = ctx.measureText(card.tag).width + 40;
                    ctx.fillStyle = '#2563eb';
                    ctx.fillRect(100, h - 140, tagW, 60);
                    ctx.strokeRect(100, h - 140, tagW, 60);
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(card.tag, 120, h - 98);

                     // ä½œè€…
                    ctx.fillStyle = '#000000';
                    const authW = ctx.measureText(card.author).width;
                    ctx.fillText(card.author, w - 100 - authW, h - 98);
                }
            },
             {
                id: 'minimal', name: 'æç®€ç•™ç™½',
                draw: (ctx, card, w, h) => {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, w, h);
                    ctx.strokeStyle = '#e5e7eb';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(20, 20, w - 40, h - 40);

                    ctx.fillStyle = '#111827';
                    ctx.font = `900 ${100 * card.scales.title}px sans-serif`;
                    ctx.fillText(card.title, 80, 150);

                    ctx.fillStyle = '#9ca3af';
                    ctx.font = `500 ${30 * card.scales.eng}px sans-serif`;
                    ctx.fillText(card.engTitle, 80, 150 + 100 * card.scales.title + 10);

                    ctx.font = '100px sans-serif';
                    ctx.fillText(card.icon, w - 180, 150);

                    ctx.fillStyle = '#1f2937';
                    ctx.font = `italic bold ${60 * card.scales.quote}px "Noto Serif SC"`;
                    drawWrappedText(ctx, card.quote, 100, h/2 - 50, w - 200, 100 * card.scales.quote, 'left');

                    ctx.fillStyle = '#d1d5db';
                    ctx.fillRect(80, h - 320, 60, 4);

                    ctx.fillStyle = '#6b7280';
                    ctx.font = `${40 * card.scales.desc}px sans-serif`;
                    drawWrappedText(ctx, card.desc, 80, h - 280, w - 160, 60 * card.scales.desc, 'left');

                    const tagW = ctx.measureText(card.tag).width + 40;
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(80, h - 120, tagW, 50);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '30px sans-serif';
                    ctx.fillText(card.tag, 100, h - 85);

                    ctx.fillStyle = '#9ca3af';
                    const authW = ctx.measureText(card.author).width;
                    ctx.fillText(card.author, w - 80 - authW, h - 85);
                }
            },
            {
                id: 'cyber', name: 'èµ›åšæ•…éšœ',
                draw: (ctx, card, w, h) => {
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, w, h);
                    ctx.strokeStyle = '#22c55e';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(20, 20, w - 40, h - 40);
                    
                    // é¡¶éƒ¨å‘å…‰æ¡
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#22c55e';
                    ctx.fillStyle = '#22c55e';
                    ctx.fillRect(20, 20, w-40, 10);
                    ctx.shadowBlur = 0;

                    ctx.fillStyle = '#22c55e';
                    ctx.font = `italic 900 ${90 * card.scales.title}px monospace`;
                    ctx.fillText(card.title.toUpperCase(), 80, 150);

                    ctx.fillStyle = '#15803d';
                    ctx.font = `${30 * card.scales.eng}px monospace`;
                    ctx.fillText(card.engTitle, 80, 150 + 90 * card.scales.title + 10);

                    ctx.font = '100px sans-serif';
                    ctx.fillText(card.icon, w - 180, 150);

                    ctx.fillStyle = 'rgba(20, 83, 45, 0.3)';
                    ctx.fillRect(60, h/2 - 120, w-120, 300);
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${50 * card.scales.quote}px monospace`;
                    drawWrappedText(ctx, card.quote, 100, h/2 - 60, w - 200, 80 * card.scales.quote, 'left');

                    ctx.fillStyle = '#86efac';
                    ctx.font = `${36 * card.scales.desc}px monospace`;
                    drawWrappedText(ctx, card.desc, 80, h - 280, w - 160, 50 * card.scales.desc, 'left');

                    ctx.fillStyle = '#22c55e';
                    ctx.fillStyle = '#22c55e';
                    ctx.fillRect(80, h - 120, ctx.measureText(card.tag).width + 30, 40);
                    ctx.fillStyle = '#000000';
                    ctx.font = '30px monospace';
                    ctx.fillText(card.tag, 95, h - 90);

                    ctx.fillStyle = '#15803d';
                    const authW = ctx.measureText(card.author).width;
                    ctx.fillText(card.author, w - 80 - authW, h - 90);
                }
            },
            {
                id: 'dark', name: 'æ·±é‚ƒé»‘é‡‘',
                draw: (ctx, card, w, h) => {
                    ctx.fillStyle = '#18181b';
                    ctx.fillRect(0, 0, w, h);
                    ctx.strokeStyle = '#27272a';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(20, 20, w - 40, h - 40);

                    ctx.fillStyle = '#eab308'; // yellow-500
                    ctx.font = `bold ${90 * card.scales.title}px "Noto Serif SC"`;
                    ctx.fillText(card.title, 80, 150);

                    ctx.fillStyle = '#52525b';
                    ctx.font = `${30 * card.scales.eng}px sans-serif`;
                    ctx.fillText(card.engTitle, 80, 150 + 90 * card.scales.title + 15);
                    // å¢åŠ å­—é—´è·æ¨¡æ‹Ÿ
                    
                    ctx.font = '100px sans-serif';
                    ctx.fillText(card.icon, w - 180, 150);

                    ctx.fillStyle = '#e5e7eb';
                    ctx.font = `300 ${60 * card.scales.quote}px "Noto Sans SC"`;
                    drawWrappedText(ctx, card.quote, 100, h/2 - 50, w - 200, 100 * card.scales.quote, 'left');

                    ctx.fillStyle = '#3f3f46';
                    ctx.fillRect(80, h - 300, 4, 80);

                    ctx.fillStyle = '#71717a';
                    ctx.font = `${40 * card.scales.desc}px "Noto Sans SC"`;
                    drawWrappedText(ctx, card.desc, 100, h - 280, w - 200, 60 * card.scales.desc, 'left');

                    ctx.fillStyle = '#ca8a04';
                    ctx.fillRect(80, h - 120, ctx.measureText(card.tag).width + 40, 50);
                    ctx.fillStyle = '#000000';
                    ctx.font = '30px sans-serif';
                    ctx.fillText(card.tag, 100, h - 85);

                    ctx.fillStyle = '#52525b';
                    const authW = ctx.measureText(card.author).width;
                    ctx.fillText(card.author, w - 80 - authW, h - 85);
                }
            }
        ];

        // --- ç»„ä»¶ï¼šCanvas æ¸²æŸ“å¡ç‰‡ ---
        const CanvasCard = ({ card, style, isSelected, onClick, scale = 1.0 }) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                
                // ç­‰å¾…å­—ä½“åŠ è½½
                document.fonts.ready.then(() => {
                    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    if (style && style.draw) {
                        style.draw(ctx, card, CANVAS_WIDTH, CANVAS_HEIGHT);
                    }
                });
            }, [card, style]);

            const displayWidth = 300 * scale;
            const displayHeight = 400 * scale;

            return (
                <div 
                    onClick={onClick}
                    className={`relative cursor-pointer transition-transform hover:scale-[1.02] ${isSelected ? 'card-highlight' : ''}`}
                    style={{ width: displayWidth, height: displayHeight, margin: '10px' }}
                >
                    <canvas
                        ref={canvasRef}
                        width={CANVAS_WIDTH}
                        height={CANVAS_HEIGHT}
                        style={{ width: '100%', height: '100%', borderRadius: '8px', boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)' }}
                    />
                </div>
            );
        };

        const App = () => {
            const [cards, setCards] = useState(defaultCards);
            const [currentIndex, setCurrentIndex] = useState(0);
            const [currentStyle, setCurrentStyle] = useState(styles[0]);
            
            const [previewCount, setPreviewCount] = useState(1);
            const [previewScale, setPreviewScale] = useState(1.0);
            const [isGlobalLock, setIsGlobalLock] = useState(true);

            const [showImport, setShowImport] = useState(false);
            const [importText, setImportText] = useState('');
            const [downloading, setDownloading] = useState(false);
            const [batchProgress, setBatchProgress] = useState(0);

            const currentCard = cards[currentIndex];

            // æ‰¹é‡ä¸‹è½½
            const downloadBatch = async () => {
                if (cards.length === 0) return;
                setDownloading(true);
                const zip = new JSZip();

                try {
                    const offscreenCanvas = document.createElement('canvas');
                    offscreenCanvas.width = CANVAS_WIDTH;
                    offscreenCanvas.height = CANVAS_HEIGHT;
                    const ctx = offscreenCanvas.getContext('2d');

                    for (let i = 0; i < cards.length; i++) {
                        setBatchProgress(Math.round(((i) / cards.length) * 100));
                        currentStyle.draw(ctx, cards[i], CANVAS_WIDTH, CANVAS_HEIGHT);
                        const blob = await new Promise(resolve => offscreenCanvas.toBlob(resolve, 'image/png'));
                        zip.file(`${i+1}_${cards[i].title}.png`, blob);
                        await new Promise(r => setTimeout(r, 10));
                    }

                    setBatchProgress(100);
                    const content = await zip.generateAsync({ type: "blob" });
                    saveAs(content, `Canvasæ‰¹é‡å¡ç‰‡.zip`);

                } catch (err) {
                    console.error(err);
                    alert("æ‰¹é‡å¯¼å‡ºå¤±è´¥");
                } finally {
                    setDownloading(false);
                    setBatchProgress(0);
                }
            };

            const downloadSingle = async () => {
                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = CANVAS_WIDTH;
                offscreenCanvas.height = CANVAS_HEIGHT;
                const ctx = offscreenCanvas.getContext('2d');
                await document.fonts.ready;
                currentStyle.draw(ctx, currentCard, CANVAS_WIDTH, CANVAS_HEIGHT);
                offscreenCanvas.toBlob(blob => {
                    saveAs(blob, `${currentCard.title}.png`);
                }, 'image/png');
            };

            const cardsToDisplay = useMemo(() => {
                const totalCards = cards.length;
                const batchStart = Math.floor(currentIndex / previewCount) * previewCount;
                let display = [];
                for (let i = 0; i < previewCount; i++) {
                    const idx = batchStart + i;
                    if (idx < totalCards) display.push({ ...cards[idx], actualIndex: idx });
                }
                let filler = 0;
                while (display.length < previewCount && filler < totalCards) {
                    display.push({ isFiller: true, id: `fill-${filler}` });
                    filler++;
                }
                return display;
            }, [cards, currentIndex, previewCount]);

            const handleNext = () => {
                 const step = previewCount > 1 ? previewCount : 1;
                 setCurrentIndex(prev => (prev + step) >= cards.length ? 0 : prev + step);
            };
            const handlePrev = () => {
                const step = previewCount > 1 ? previewCount : 1;
                setCurrentIndex(prev => {
                    const next = prev - step;
                    return next < 0 ? Math.floor((cards.length - 1) / step) * step : next;
                });
            };

            const handleCardUpdate = (field, value) => {
                const newCards = [...cards];
                newCards[currentIndex] = { ...newCards[currentIndex], [field]: value };
                setCards(newCards);
            };
            const adjustScale = (field, delta) => {
                const change = delta / 10;
                const updater = (c) => ({ ...c, scales: { ...c.scales, [field]: Math.max(0.2, (c.scales[field] || 1.0) + change) } });
                if (isGlobalLock) setCards(prev => prev.map(updater));
                else {
                    const newCards = [...cards];
                    newCards[currentIndex] = updater(newCards[currentIndex]);
                    setCards(newCards);
                }
            };
            const handleImport = () => {
                try {
                    const d = JSON.parse(importText);
                    if(Array.isArray(d)) {
                        setCards(d.map(c => ({ ...c, scales: {title:1,eng:1,quote:1,desc:1} })));
                        setCurrentIndex(0); setShowImport(false);
                    }
                } catch(e){ alert("JSON Error"); }
            };

            // ä¿®æ”¹åçš„ç´§å‡‘è¾“å…¥ç»„ä»¶
            const ControlInput = ({ value, field, placeholder, multiline, scaleField }) => (
                <div className="flex gap-2 items-stretch h-9"> {/* å›ºå®šé«˜åº¦ h-9 (36px) */}
                    {multiline ? 
                        <textarea 
                            value={value} 
                            onChange={e=>handleCardUpdate(field, e.target.value)} 
                            className="flex-1 bg-[#333] border border-[#444] rounded px-2 py-1.5 text-white text-xs focus:outline-none resize-none input-scrollbar leading-tight" 
                            placeholder={placeholder}
                            style={{ whiteSpace: 'pre-wrap' }} // å…è®¸æ¢è¡Œä½†åªæ˜¾ç¤ºä¸€è¡Œ
                        /> :
                        <input 
                            type="text" 
                            value={value} 
                            onChange={e=>handleCardUpdate(field, e.target.value)} 
                            className="flex-1 bg-[#333] border border-[#444] rounded px-2 py-1 text-white text-xs focus:outline-none" 
                            placeholder={placeholder} 
                        />
                    }
                    {scaleField && (
                        <div className="flex flex-col w-6 gap-[1px]"> {/* æ›´çª„çš„æŒ‰é’® */}
                             <button onClick={()=>adjustScale(scaleField, 1)} className="flex-1 bg-[#444] text-white text-[10px] rounded-t hover:bg-[#555] flex items-center justify-center">ï¼‹</button>
                             <button onClick={()=>adjustScale(scaleField, -1)} className="flex-1 bg-[#444] text-white text-[10px] rounded-b hover:bg-[#555] flex items-center justify-center">ï¼</button>
                        </div>
                    )}
                </div>
            );

            return (
                <div className="min-h-screen flex flex-col md:flex-row bg-[#111]">
                    {/* å³ä¾§é¢„è§ˆ (ç½®é¡¶/å³ä¾§) */}
                    <div className="flex-1 bg-[#111] flex flex-col order-1 md:order-2 overflow-hidden h-[50vh] md:h-screen">
                        <div className="flex items-center justify-between px-4 py-3 bg-[#1a1a1a] border-b border-[#333]">
                            <div className="flex gap-2">
                                <button onClick={handlePrev} className="w-8 h-8 bg-[#333] text-gray-400 rounded-full hover:bg-[#444]">â†</button>
                                <span className="text-xs font-mono text-gray-500 flex items-center">{currentIndex+1}/{cards.length}</span>
                                <button onClick={handleNext} className="w-8 h-8 bg-[#333] text-gray-400 rounded-full hover:bg-[#444]">â†’</button>
                            </div>
                            <div className="flex gap-4 items-center">
                                <div className="flex items-center gap-1">
                                    <button onClick={()=>setPreviewScale(s=>Math.max(0.2,s-0.1))} className="p-1 text-gray-400 hover:text-white text-lg">-</button>
                                    <span className="text-xs text-gray-500 w-8 text-center">{Math.round(previewScale*100)}%</span>
                                    <button onClick={()=>setPreviewScale(s=>Math.min(2,s+0.1))} className="p-1 text-gray-400 hover:text-white text-lg">+</button>
                                </div>
                                <div className="flex border border-[#333] rounded overflow-hidden">
                                    {[1,2,3,6].map(n => (
                                        <button key={n} onClick={()=>setPreviewCount(n)} className={`px-3 py-1 text-xs ${previewCount===n?'bg-blue-600 text-white':'bg-[#222] text-gray-500'}`}>{n}</button>
                                    ))}
                                </div>
                            </div>
                        </div>

                        <div className="flex-1 overflow-auto p-4 flex flex-wrap content-start justify-center gap-4 bg-[#0c0c0c]">
                            {cardsToDisplay.map((item, idx) => (
                                item.isFiller ? 
                                <div key={idx} style={{width: 300*previewScale, height: 400*previewScale}} className="border border-dashed border-[#333] flex items-center justify-center text-[#333]">ç©º</div> :
                                <CanvasCard 
                                    key={idx} 
                                    card={item} 
                                    style={currentStyle} 
                                    scale={previewScale}
                                    isSelected={item.actualIndex === currentIndex}
                                    onClick={() => setCurrentIndex(item.actualIndex)}
                                />
                            ))}
                        </div>

                        <div className="p-4 bg-[#1a1a1a] border-t border-[#333] flex gap-3 justify-center">
                            {downloading ? 
                                <span className="text-blue-500 animate-pulse text-sm font-bold">æ­£åœ¨åŸç”Ÿç»˜åˆ¶... {batchProgress}%</span> :
                                <>
                                    <button onClick={downloadSingle} className="px-6 py-2 bg-gray-700 text-white text-sm font-bold rounded hover:bg-gray-600">ä¿å­˜å•å¼ </button>
                                    <button onClick={downloadBatch} className="px-6 py-2 bg-blue-600 text-white text-sm font-bold rounded hover:bg-blue-500">æ‰¹é‡ Canvas å¯¼å‡º</button>
                                </>
                            }
                        </div>
                    </div>

                    {/* å·¦ä¾§ç¼–è¾‘ - ç´§å‡‘ç‰ˆ */}
                    <div className="w-full md:w-[320px] bg-[#1a1a1a] border-r border-[#333] flex flex-col order-2 md:order-1 h-[50vh] md:h-screen shadow-xl z-10">
                        <div className="p-3 border-b border-[#333] flex gap-2">
                             <button onClick={()=>setShowImport(true)} className="flex-1 bg-green-700 hover:bg-green-600 text-white py-1.5 rounded text-xs font-bold transition-colors">JSON å¯¼å…¥</button>
                             <button onClick={()=>{if(confirm('æ¸…ç©º?')) setCards([defaultCards[0]])}} className="bg-red-900/50 hover:bg-red-900/80 text-red-200 px-3 rounded transition-colors">ğŸ—‘ï¸</button>
                        </div>
                        
                        <div className="flex-1 overflow-y-auto p-3 space-y-2.5 no-scrollbar">
                            <div className="flex justify-between items-center mb-1">
                                <span className="text-[10px] font-bold text-gray-500 uppercase tracking-wider">å†…å®¹ç¼–è¾‘</span>
                                <button onClick={()=>setIsGlobalLock(!isGlobalLock)} className={`text-[10px] px-2 py-0.5 rounded border transition-all ${isGlobalLock?'bg-blue-900/50 text-blue-200 border-blue-800':'border-[#333] text-gray-500 hover:text-gray-300'}`}>
                                    {isGlobalLock ? 'ğŸ”’ æ‰¹é‡è°ƒæ•´' : 'ğŸ”“ å•å¼ è°ƒæ•´'}
                                </button>
                            </div>

                            <ControlInput field="title" value={currentCard.title} placeholder="æ ‡é¢˜" scaleField="title" />
                            <ControlInput field="icon" value={currentCard.icon} placeholder="å›¾æ ‡" />
                            <ControlInput field="engTitle" value={currentCard.engTitle} placeholder="è‹±æ–‡" scaleField="eng" />
                            <ControlInput field="quote" value={currentCard.quote} placeholder="é‡‘å¥ (å¯æ»šåŠ¨)" multiline scaleField="quote" />
                            <ControlInput field="desc" value={currentCard.desc} placeholder="æè¿° (å¯æ»šåŠ¨)" multiline scaleField="desc" />
                            <div className="grid grid-cols-2 gap-2">
                                <ControlInput field="tag" value={currentCard.tag} placeholder="#æ ‡ç­¾" />
                                <ControlInput field="author" value={currentCard.author} placeholder="@ä½œè€…" />
                            </div>

                            <div className="pt-3 border-t border-[#333] mt-2">
                                <div className="text-[10px] font-bold text-gray-500 mb-2 uppercase tracking-wider">é£æ ¼é€‰æ‹©</div>
                                <div className="grid grid-cols-2 gap-2">
                                    {styles.map(s => (
                                        <button key={s.id} onClick={()=>setCurrentStyle(s)} className={`py-1.5 px-2 text-xs text-center rounded border transition-all ${currentStyle.id===s.id?'bg-blue-600 border-blue-500 text-white shadow-lg shadow-blue-900/50':'bg-[#222] border-[#333] text-gray-400 hover:bg-[#2a2a2a]'}`}>
                                            {s.name}
                                        </button>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>

                     {/* å¯¼å…¥å¼¹çª— */}
                     {showImport && (
                        <div className="fixed inset-0 bg-black/90 z-50 flex items-center justify-center p-4">
                            <div className="bg-[#222] w-full max-w-lg rounded-xl border border-[#444] flex flex-col h-[50vh]">
                                <div className="p-4 border-b border-[#333] flex justify-between text-white font-bold"><span>å¯¼å…¥ JSON</span><button onClick={() => setShowImport(false)}>âœ•</button></div>
                                <textarea value={importText} onChange={(e) => setImportText(e.target.value)} className="flex-1 bg-[#111] text-green-400 p-4 resize-none outline-none font-mono text-xs" placeholder='JSON æ•°ç»„...'></textarea>
                                <button onClick={handleImport} className="bg-blue-600 active:bg-blue-500 text-white py-3 font-bold m-4 rounded">ç¡®è®¤è§£æ</button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

